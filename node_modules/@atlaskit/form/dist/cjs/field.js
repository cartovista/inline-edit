"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FieldId = void 0;
exports.default = Field;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _react = require("react");

var _core = require("@emotion/core");

var _reactUid = require("react-uid");

var _tinyInvariant = _interopRequireDefault(require("tiny-invariant"));

var _colors = require("@atlaskit/theme/colors");

var _constants = require("@atlaskit/theme/constants");

var _form = require("./form");

var _label = _interopRequireDefault(require("./label"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var gridSize = (0, _constants.gridSize)();
var fontFamily = (0, _constants.fontFamily)();
var fieldWrapperStyles = (0, _core.css)({
  marginTop: gridSize
});
var requiredIndicatorStyles = (0, _core.css)({
  paddingLeft: "".concat(gridSize / 4, "px"),
  color: "var(--ds-text-danger, ".concat(_colors.R400, ")"),
  fontFamily: fontFamily
});

function isEvent(event) {
  return Boolean(event && event.target);
}

function isFunction(x) {
  return typeof x === 'function';
}

/**
 * __Field id__
 *
 * A field id uses the context API. It provides the id of the field to message components. This links the message with the field of screenreaders.
 */
var FieldId = /*#__PURE__*/(0, _react.createContext)(undefined);
exports.FieldId = FieldId;

function usePreviousRef(current) {
  var ref = (0, _react.useRef)(current); // will be updated on the next render

  (0, _react.useEffect)(function () {
    ref.current = current;
  }); // return the existing current (pre render)

  return ref;
}

function isShallowEqual(previousValue, currentValue) {
  if (previousValue === currentValue) {
    return true;
  } // not checking functions


  if (typeof previousValue === 'function' && typeof currentValue === 'function') {
    return true;
  }

  if (Array.isArray(previousValue) && Array.isArray(currentValue)) {
    return JSON.stringify(previousValue) === JSON.stringify(currentValue);
  }

  if ((0, _typeof2.default)(previousValue) === 'object' && (0, _typeof2.default)(currentValue) === 'object') {
    return JSON.stringify(previousValue) === JSON.stringify(currentValue);
  }

  return false;
}

function Field(props) {
  var registerField = (0, _react.useContext)(_form.FormContext);
  var isDisabled = (0, _react.useContext)(_form.IsDisabledContext) || props.isDisabled || false;
  var defaultValue = isFunction(props.defaultValue) ? props.defaultValue() : props.defaultValue;

  var _useState = (0, _react.useState)({
    fieldProps: {
      onChange: function onChange() {},
      onBlur: function onBlur() {},
      onFocus: function onFocus() {},

      /* Previously, defaultValue was being set as undefined in Field.defaultProps, which
       * effectively made it an optional prop to external consumers of Field. However the
       * prop types defined defaultValue as required, so inside the component it was not
       * valid for defaultValue to be undefined. We need to suppress the error
       * after changing defaultValue to explictly be an optional prop.
       */
      // @ts-ignore
      value: defaultValue
    },
    error: undefined,
    valid: false,
    meta: {
      dirty: false,
      dirtySinceLastSubmit: false,
      touched: false,
      valid: false,
      validating: false,
      submitting: false,
      submitFailed: false,
      error: undefined,
      submitError: undefined
    }
  }),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  var latestPropsRef = usePreviousRef(props);
  var latestStateRef = usePreviousRef(state);
  /**
   * HACK: defaultValue can potentially be an array or object which cannot be
   * passed directly into a `useEffect` dependency array, since it will trigger
   * the hook every time.
   */

  var hasDefaultValueChanged = isShallowEqual(latestPropsRef.current.defaultValue, props.defaultValue);
  (0, _react.useEffect)(function () {
    if (process.env.NODE_ENV !== 'production' && !process.env.CI) {
      (0, _tinyInvariant.default)(latestPropsRef.current.name, '@atlaskit/form: Field components have a required name prop');
    }

    function fieldStateToMeta() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return {
        dirty: value.dirty || false,
        dirtySinceLastSubmit: value.dirtySinceLastSubmit || false,
        touched: value.touched || false,
        valid: value.valid || false,
        submitting: value.submitting || false,
        submitFailed: value.submitFailed || false,
        error: value.error,
        submitError: value.submitError,
        validating: !!value.validating
      };
    }

    var unregister = registerField(latestPropsRef.current.name, // @ts-ignore
    latestPropsRef.current.defaultValue, function (fieldState) {
      /**
       * Do not update dirtySinceLastSubmit until submission has finished.
       */
      var modifiedDirtySinceLastSubmit = fieldState.submitting ? latestStateRef.current.meta.dirtySinceLastSubmit : fieldState.dirtySinceLastSubmit;
      /**
       * Do not update submitFailed until submission has finished.
       */

      var modifiedSubmitFailed = fieldState.submitting ? latestStateRef.current.meta.submitFailed : fieldState.submitFailed;
      /**
       * Do not use submitError if the value has changed.
       */

      var modifiedSubmitError = modifiedDirtySinceLastSubmit && latestPropsRef.current.validate ? undefined : fieldState.submitError;
      var modifiedError = modifiedSubmitError || (fieldState.touched || fieldState.dirty) && fieldState.error;
      /**
       * If there has been a submit error, then use logic in modifiedError to determine validity,
       * so we can determine when there is a submit error which we do not want to display
       * because the value has been changed.
       */

      var modifiedValid = modifiedSubmitFailed ? modifiedError === undefined : fieldState.valid;

      function getTransform(eventOrValue, currentValue) {
        if (latestPropsRef.current.transform) {
          return latestPropsRef.current.transform(eventOrValue, currentValue);
        }

        if (isEvent(eventOrValue)) {
          var currentTarget = eventOrValue.currentTarget;

          if (currentTarget.type === 'checkbox') {
            //@ts-expect-error TODO Fix legit TypeScript 3.9.6 improved inference error
            if (currentTarget.checked) {
              return currentTarget.value || true;
            }

            return currentTarget.value ? undefined : false;
          } else if (currentTarget) {
            return currentTarget.value;
          }
        } else {
          return eventOrValue;
        }
      }

      setState({
        fieldProps: {
          onChange: function onChange(e) {
            fieldState.change(getTransform(e, fieldState.value));
          },
          onBlur: fieldState.blur,
          onFocus: fieldState.focus,
          value: fieldState.value
        },
        error: modifiedError || undefined,

        /**
         * The following parameters are optionally typed in final-form to indicate that not all parameters need
         * to be subscribed to. We cast them as booleans (using || false), since this is what they are semantically.
         */
        valid: modifiedValid || false,
        meta: fieldStateToMeta(fieldState)
      });
    }, {
      dirty: true,
      dirtySinceLastSubmit: true,
      touched: true,
      valid: true,
      submitting: true,
      submitFailed: true,
      value: true,
      error: true,
      submitError: true,
      validating: true
    }, {
      getValidator: function getValidator() {
        return function validate(value, formState, fieldState) {
          var supplied = latestPropsRef.current.validate;

          if (supplied && fieldState) {
            return supplied(value, formState, fieldStateToMeta(fieldState));
          }
        };
      }
    });
    return unregister;
  }, [latestPropsRef, latestStateRef, registerField, props.name, hasDefaultValueChanged]);
  var fieldId = (0, _react.useMemo)( // eslint-disable-next-line @repo/internal/react/disallow-unstable-values
  function () {
    return props.id ? props.id : "".concat(props.name, "-").concat((0, _reactUid.uid)({
      id: props.name
    }));
  }, [props.id, props.name]);

  var extendedFieldProps = _objectSpread(_objectSpread({}, state.fieldProps), {}, {
    name: props.name,
    isDisabled: isDisabled,
    isInvalid: Boolean(state.error),
    isRequired: Boolean(props.isRequired),
    'aria-invalid': state.error ? 'true' : 'false',
    'aria-labelledby': "".concat(fieldId, "-label ").concat(fieldId, "-helper ").concat(fieldId, "-valid ").concat(fieldId, "-error"),
    id: fieldId
  });

  return (0, _core.jsx)("div", {
    css: fieldWrapperStyles
  }, props.label && (0, _core.jsx)(_label.default, {
    htmlFor: fieldId,
    id: "".concat(fieldId, "-label")
  }, props.label, props.isRequired && (0, _core.jsx)("span", {
    css: requiredIndicatorStyles,
    "aria-hidden": "true"
  }, "*")), (0, _core.jsx)(FieldId.Provider, {
    value: fieldId
  }, props.children({
    fieldProps: extendedFieldProps,
    error: state.error,
    valid: state.valid,
    meta: state.meta
  })));
}