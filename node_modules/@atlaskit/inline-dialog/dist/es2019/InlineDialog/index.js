/** @jsx jsx */
import React, { memo, useCallback, useEffect, useRef } from 'react';
import { jsx } from '@emotion/core';
import { bind } from 'bind-event-listener';
import NodeResolver from 'react-node-resolver';
import { createAndFireEvent, withAnalyticsContext, withAnalyticsEvents } from '@atlaskit/analytics-next';
import noop from '@atlaskit/ds-lib/noop';
import { Manager, Popper, Reference } from '@atlaskit/popper';
import { Container } from './styled/container';
const packageName = "@atlaskit/inline-dialog";
const packageVersion = "13.3.2";

const checkIsChildOfPortal = node => {
  if (!node) {
    return false;
  }

  return node.classList && node.classList.contains('atlaskit-portal-container') || checkIsChildOfPortal(node.parentElement);
};

const InlineDialog = /*#__PURE__*/memo(function InlineDialog({
  isOpen = false,
  onContentBlur = noop,
  onContentClick = noop,
  onContentFocus = noop,
  onClose = noop,
  placement = 'bottom-start',
  strategy = 'fixed',
  testId,
  content,
  children
}) {
  const containerRef = useRef(null);
  const triggerRef = useRef(null); // we put this into a ref to avoid handleClickOutside having this as a dependency

  const onCloseRef = useRef(onClose);
  useEffect(() => {
    onCloseRef.current = onClose;
  });
  const handleClickOutside = useCallback(event => {
    const {
      target
    } = event; // checks for when target is not HTMLElement

    if (!(target instanceof HTMLElement)) {
      return;
    } // TODO: This is to handle the case where the target is no longer in the DOM.
    // This happens with react-select in datetime picker. There might be other
    // edge cases for this.


    if (!document.body.contains(target)) {
      return;
    } // exit if we click outside but on the trigger â€” it can handle the clicks itself


    if (triggerRef.current && triggerRef.current.contains(target)) {
      return;
    } // handles the case where inline dialog opens portalled elements such as modal


    if (checkIsChildOfPortal(target)) {
      return;
    } // call onClose if the click originated from outside the dialog


    if (containerRef.current && !containerRef.current.contains(target)) {
      var _onCloseRef$current;

      (_onCloseRef$current = onCloseRef.current) === null || _onCloseRef$current === void 0 ? void 0 : _onCloseRef$current.call(onCloseRef, {
        isOpen: false,
        event: event
      });
    }
  }, []);
  useEffect(() => {
    if (!isOpen) {
      return;
    }

    let unbind;
    unbind = bind(window, {
      type: 'click',
      listener: e => handleClickOutside(e),
      options: {
        capture: true
      }
    });
    return unbind;
  }, [isOpen, handleClickOutside]);
  const popper = isOpen ? jsx(Popper, {
    placement: placement,
    strategy: strategy
  }, ({
    ref,
    style
  }) => jsx(Container, {
    onBlur: onContentBlur,
    onFocus: onContentFocus,
    onClick: onContentClick,
    ref: node => {
      if (node) {
        containerRef.current = node;

        if (typeof ref === 'function') {
          ref(node);
        } else {
          ref.current = node;
        }
      }
    },
    style: style,
    testId: testId
  }, content)) : null;
  return jsx(Manager, null, jsx(Reference, null, ({
    ref
  }) => jsx(NodeResolver, {
    innerRef: node => {
      triggerRef.current = node;

      if (typeof ref === 'function') {
        ref(node);
      } else {
        ref.current = node;
      }
    }
  }, children)), popper);
});
InlineDialog.displayName = 'InlineDialog';
export { InlineDialog as InlineDialogWithoutAnalytics };
const createAndFireEventOnAtlaskit = createAndFireEvent('atlaskit');
export default withAnalyticsContext({
  componentName: 'inlineDialog',
  packageName,
  packageVersion
})(withAnalyticsEvents({
  onClose: createAndFireEventOnAtlaskit({
    action: 'closed',
    actionSubject: 'inlineDialog',
    attributes: {
      componentName: 'inlineDialog',
      packageName,
      packageVersion
    }
  })
})(InlineDialog));